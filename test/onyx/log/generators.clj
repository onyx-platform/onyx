(ns onyx.log.generators
  (:require [clojure.core.async :refer [chan >!! <!! close!]]
            [onyx.messaging.dummy-messenger :refer [dummy-messenger]]
            [onyx.log.entry :refer [create-log-entry]]
            [onyx.log.commands.common :refer [peer->allocated-job]]
            [onyx.extensions :as extensions]
            [onyx.api :as api]
            [taoensso.timbre :as timbre :refer [info]]
            [clojure.set :refer [intersection]]
            [clojure.test.check :as tc]
            [clojure.test.check.generators :as gen]
            [clojure.test.check.properties :as prop]
            [clojure.test :refer :all]))

(def messenger (dummy-messenger {:onyx.peer/try-join-once? false}))

(defn peerless-entry? [log-entry]
  (#{:submit-job :kill-job :gc} (:fn log-entry)))

(defn active-peers [replica entry]
  (cond-> (set (concat (:peers replica)
                       ; might not need these with the below entries
                       (vals (or (:prepared replica) {}))
                       (vals (or (:accepted replica) {}))))
    ;; joining peer's prepared/accepted may have been removed
    ;; by a leave cluster but the joining peer is still there
    (and (not (peerless-entry? entry))
         (:observer (:args entry)))
    (conj (:observer (:args entry)))
    (and (not (peerless-entry? entry))
         (:id (:args entry)))
    (conj (:id (:args entry)))
    (and (not (peerless-entry? entry))
         (:accepted-joiner (:args entry)))
    (conj (:accepted-joiner (:args entry)))
    (and (not (peerless-entry? entry))
         (:joiner (:args entry)))
    (conj (:joiner (:args entry)))))

(defn generate-side-effects
  "Generates additional reactions that may be generated by the process.
  e.g. when the task lifecycle is ready, it signals via :signal-ready"
  [entry old new diff peer-id]
  (cond (#{:kill-job :submit-job :prepare-join-cluster 
           :accept-join-cluster :leave-cluster} (:fn entry))
    (let [old-allocation (peer->allocated-job (:allocations old) peer-id)
          new-allocation (peer->allocated-job (:allocations new) peer-id)]
      (if (and new-allocation (not= old-allocation new-allocation))
        [peer-id [(create-log-entry :signal-ready {:id peer-id})]]))))

(def base-peer-state 
  {:messenger messenger
   :opts {:onyx.peer/try-join-once?
          (:onyx.peer/try-join-once? (:opts messenger) true)}})

(defn apply-entry [replica entries entry]
  (let [new-replica (extensions/apply-log-entry entry replica)
        diff (extensions/replica-diff entry replica new-replica)
        peers (active-peers new-replica entry)
        peer-reactions (keep (fn [peer-id]
                               (if-let [reactions (seq (extensions/reactions entry replica new-replica diff (assoc base-peer-state :id peer-id)))]
                                 [peer-id reactions]))
                             peers)
        side-effects (keep (fn [peer-id] 
                             (generate-side-effects entry replica new-replica diff peer-id)) 
                           peers)
        new (concat peer-reactions side-effects)
        ; it does not matter that multiple reactions are processed
        ; together because they may be processed interleaved depending on
        ; the choice of peer queue being popped
        unapplied (reduce (fn [new-entries [peer-id reactions]]
                            (update-in new-entries 
                                       [peer-id :queue]
                                       (fn [queue]
                                         (-> queue
                                             vec
                                             (into reactions)))))
                          entries
                          new)]
    (vector new-replica diff unapplied)))

(defn apply-peer-queue-entry
  "Applies the next log message in the selected peer's queue.
  Effectively, the next peer that wrote its message to ZK"
  [{:keys [replica message-id entries peer-choices log]} next-peer]
  (let [peer-queue (:queue (entries next-peer))
        next-entry (first peer-queue)
        new-peer-queue (vec (rest peer-queue))
        new-entries (if (empty? new-peer-queue)
                      (dissoc entries next-peer)
                      (assoc-in entries [next-peer :queue] new-peer-queue))
        message (assoc next-entry :message-id message-id)
        [new-replica diff updated-entries] (apply-entry replica new-entries message)]
    {:replica new-replica
     :message-id (inc message-id)
     :entries updated-entries
     :log (conj log [message diff])
     :peer-choices (conj peer-choices next-peer)}))

(defn queue-select-gen
  "Generator to look into all of the peer's write queues
  and pick an entry to get fake written next"
  [replica-state-gen]
  (gen/bind replica-state-gen
            (fn [state]
              ;; we only play back log messages from peers who have joined
              (let [replica (:replica state)
                    peerless-queues (->> (:entries state)
                                         (filter (fn [[queue-id {:keys [predicate queue]}]]
                                                   (or (peerless-entry? (first queue))
                                                       ((or predicate (constantly true))
                                                        replica
                                                        (first queue)))))
                                         (map key))
                    joined-peers (set (:peers replica))
                    selectable-peers (->> (:entries state)
                                          (filter (fn [[peer {:keys [queue]}]]
                                                    (let [entry (first queue)]
                                                      (contains? joined-peers peer))))
                                          (map key)
                                          set)
                    selectable-queues (into selectable-peers peerless-queues)]
                (if (empty? selectable-queues)
                  (throw (Exception. (str "No playable log messages. State: " state)))
                  (gen/elements selectable-queues))))))

(defn apply-entry-gen
  "Apply an entry from one of the peers log queues
  to a replica generator "
  [replica-state-gen]
  (gen/fmap
    (fn [[state peer-id]]
      (apply-peer-queue-entry state peer-id))
    (gen/tuple replica-state-gen
               (queue-select-gen replica-state-gen))))

(defn apply-entries-gen
  "Recurse over replica generator until entries
  are exhausted. Return the final replica, the log messages
  in the order they were written and the order of the peers
  that got to write"
  [replica-state-gen]
  (gen/bind replica-state-gen
            (fn [state]
              (let [g (gen/return state)]
                (when (> (count (:log state))
                         1000)
                  (throw (Exception. (str "Log entry generator overflow. Likely issue with uncompletable log\n"
                                          (with-out-str (clojure.pprint/pprint state))))))
                (if (empty? (:entries state))
                  g
                  (apply-entries-gen (apply-entry-gen g)))))))

(defn build-join-entry
  ([peer-id]
   (build-join-entry peer-id {}))
  ([peer-id more-args]
   {:fn :prepare-join-cluster
    :args (merge {:peer-site (extensions/peer-site messenger)
                  :joiner peer-id}
                 more-args)}))

(defn generate-join-queues
  ([peer-ids]
   (generate-join-queues peer-ids {}))
  ([peer-ids more-join-args]
   (zipmap peer-ids
           (map (fn [peer]
                  {:queue [(build-join-entry peer more-join-args)]})
                peer-ids))))

;; Start at peer ID n, then generate m more ids
(defn generate-peer-ids
  ([n]
   (generate-peer-ids 1 n))
  ([n m]
   (map #(keyword (str "p" %))
        (range n (+ n m)))))
